{"slots":{"0":{"name":"core","type":{"events":[],"methods":[]}},"1":{"name":"atmofueltank_1","type":{"events":[],"methods":[]}},"2":{"name":"screenMain","type":{"events":[],"methods":[]}},"3":{"name":"screenTelemetry","type":{"events":[],"methods":[]}},"4":{"name":"slot5","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-3":{"name":"player","type":{"events":[],"methods":[]}},"-2":{"name":"construct","type":{"events":[],"methods":[]}},"-4":{"name":"system","type":{"events":[],"methods":[]}},"-5":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"-- category panel display helpers\n_autoconf = {}\n_autoconf.panels = {}\n_autoconf.panels_size = 0\n_autoconf.displayCategoryPanel = function(elements, size, title, type, widgetPerData)\n    widgetPerData = widgetPerData or false -- default to one widget for all data\n    if size > 0 then\n        local panel = system.createWidgetPanel(title)\n        local widget\n        if not widgetPerData then\n            widget = system.createWidget(panel, type)\n        end\n        for i = 1, size do\n            if widgetPerData then\n                widget = system.createWidget(panel, type)\n            end\n            system.addDataToWidget(elements[i].getWidgetDataId(), widget)\n        end\n        _autoconf.panels_size = _autoconf.panels_size + 1\n        _autoconf.panels[_autoconf.panels_size] = panel\n    end\nend\n_autoconf.hideCategoryPanels = function()\n    for i=1,_autoconf.panels_size do\n        system.destroyWidgetPanel(_autoconf.panels[i])\n    end\nend\n-- Proxy array to access auto-plugged slots programmatically\n\natmofueltank = {}\natmofueltank[1] = atmofueltank_1\natmofueltank_size = 1\n\nspacefueltank = {}\nspacefueltank_size = 0\n\nrocketfueltank = {}\nrocketfueltank_size = 0\n\nweapon = {}\nweapon_size = 0\n\nradar = {}\nradar_size = 0\n-- End of auto-generated code\npitchInput = 0\nrollInput = 0\nyawInput = 0\nbrakeInput = 0\n\nNav = Navigator.new(system, core, unit)\nNav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {1000, 5000, 10000, 20000, 30000})\nNav.axisCommandManager:setTargetGroundAltitude(150)\n\n-- Parenting widget\nparentingPanelId = system.createWidgetPanel(\"Docking\")\nparentingWidgetId = system.createWidget(parentingPanelId,\"parenting\")\nsystem.addDataToWidget(unit.getWidgetDataId(),parentingWidgetId)\n\n-- Combat stress widget\ncoreCombatStressPanelId = system.createWidgetPanel(\"Core combat stress\")\ncoreCombatStressgWidgetId = system.createWidget(coreCombatStressPanelId,\"core_stress\")\nsystem.addDataToWidget(core.getWidgetDataId(),coreCombatStressgWidgetId)\n\n-- element widgets\n-- For now we have to alternate between PVP and non-PVP widgets to have them on the same side.\n_autoconf.displayCategoryPanel(weapon, weapon_size, \"Weapons\", \"weapon\", true)\ncore.showWidget()\n_autoconf.displayCategoryPanel(radar, radar_size, \"Periscope\", \"periscope\")\nplaceRadar = true\nif atmofueltank_size > 0 then\n    _autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, \"Atmo Fuel\", \"fuel_container\")\n    if placeRadar then\n        _autoconf.displayCategoryPanel(radar, radar_size, \"Radar\", \"radar\")\n        placeRadar = false\n    end\nend\nif spacefueltank_size > 0 then\n    _autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, \"Space Fuel\", \"fuel_container\")\n    if placeRadar then\n        _autoconf.displayCategoryPanel(radar, radar_size, \"Radar\", \"radar\")\n        placeRadar = false\n    end\nend\n_autoconf.displayCategoryPanel(rocketfueltank, rocketfueltank_size, \"Rocket Fuel\", \"fuel_container\")\nif placeRadar then -- We either have only rockets or no fuel tanks at all, uncommon for usual vessels\n    _autoconf.displayCategoryPanel(radar, radar_size, \"Radar\", \"radar\")\n    placeRadar = false\nend\nif antigrav ~= nil then antigrav.showWidget() end\nif warpdrive ~= nil then warpdrive.showWidget() end\nif gyro ~= nil then gyro.showWidget() end\nif shield ~= nil then shield.showWidget() end\n\n-- freeze the player in he is remote controlling the construct\nif unit.isRemoteControlled() == 1 then\n    player.freeze(1)\nend\n\n-- landing gear\n-- make sure every gears are synchonized with the first\ngearExtended = (unit.isAnyLandingGearDeployed() == 1) -- make sure it's a lua boolean\nif gearExtended then\n    unit.deployLandingGears()\nelse\n    unit.retractLandingGears()\nend\n\n\nAlioth = Planet:new(0, 0, 199718.78, vec3(-8.0000, -8.0000, -126303.0000), 126067.8984375)\n\nap = AutoPilot:new(false)\nap.currentPlanet = Alioth\nap.targetAltitude = 125\nap.currentTarget = getDestination(ap.currentPlanet.center, vec3(construct.getWorldPosition()), ap.targetAltitude)\nap.positionHoldEnabled = true\n\nunit.setTimer(\"tickAltitude\", 0.1)\nunit.setTimer(\"tickDisplay\", 0.5)","filter":{"args":[],"signature":"onStart()","slotKey":"-1"},"key":"0"},{"code":"_autoconf.hideCategoryPanels()\nif antigrav ~= nil then antigrav.hideWidget() end\nif warpdrive ~= nil then warpdrive.hideWidget() end\nif gyro ~= nil then gyro.hideWidget() end\ncore.hideWidget()\nunit.switchOffHeadlights()\n","filter":{"args":[],"signature":"onStop()","slotKey":"-1"},"key":"1"},{"code":"--tickAltitude(TickRate:0.1)\n\n--initalize\nif not altitudeInit then\n    altitudeInit = true\n\n    verticalThrustSolution = vec3(0,0,0)\nend\n\n-- only do calculations when ap is on\nif ap.enabled then\n    \n    ap.currentPosition = vec3(construct.getWorldPosition())\n    ap.currentAltitude = getAltitude(ap.currentPosition, ap.currentPlanet)\n    ap.currentVelocity = construct.getWorldAbsoluteVelocity()\n    ap.currentAcceleration = construct.getWorldAcceleration()\n    ap.altitudePID:inject(ap.targetAltitude - ap.currentAltitude)\n    ap.thrustUp = unit.getEngineThrust(\"thrustUp\")\n    ap.thrustDown = unit.getEngineThrust(\"thrustDown\")\n    ap.thrustRight = unit.getEngineThrust(\"thrustRight\")\n    ap.thrustLeft = unit.getEngineThrust(\"thrustLeft\")\n    ap.thrustForwards = unit.getEngineThrust(\"thrustForwards\")\n    ap.thrustBack = unit.getEngineThrust(\"thrustBack\")\n    ap.pitchSpeedFactor = 0\n    ap.yawSpeedFactor = 0\n    ap.rollSpeedFactor = 0\n    ap.torqueFactor = 0\n    ap.brakeSpeedFactor = 0\n    ap.brakeFlatFactor = 0\n    ap.autoRollFactor = 0\n    ap.turnAssistFactor = 0\n    ap.forwardInput = system.getControlDeviceForwardInput()\n    ap.yawInput = system.getControlDeviceYawInput()\n    ap.leftRightInput = system.getControlDeviceLeftRightInput()\n    ap.longitudinalAcceleration = 0\n    ap.lateralAcceleration = 0\n    ap.verticalAcceleration = 0\n    ap.brakeInput = false\n\n    -- figure out verticalThrustSolution\n    targetHeight = 130\n    heightDelta = targetHeight - ap.currentAltitude\n    if heightDelta < 0 then\n        ap.verticalAcceleration = 0\n        ap.brakeInput = true\n    elseif heightDelta > 100 then ap.verticalAcceleration = 20\n    elseif heightDelta > 50 then ap.verticalAcceleration = 10\n    else ap.verticalAcceleration = 5\n    end\n\n    screenMain.setCenteredText(\"HeightDelta: \" .. heightDelta .. \"/n\" ..\n                               \"Target Speed Up: \" .. ap.verticalAcceleration .. \"/n\" ..\n                               \"Target Speed Forward: \" .. ap.lateralAcceleration .. \"/n\" ..\n                               \"Target Speed Left: \" .. ap.longitudinalAcceleration )\n\nend\n\n","filter":{"args":[{"value":"tickAltitude"}],"signature":"onTimer(tag)","slotKey":"-1"},"key":"2"},{"code":"--tickDisplay(TickRate:0.5)\n\n--initalize\nif not displayInit then\n    displayInit = true\n    fontSize = \"2.1\"\nend\n\nrenderScript = [[\n\n\tnewState = {\n\t\tpos1 = 1,\n\t\tpos2 = 2,\n\t\tpos3 = 3,\n\t\tpos4 = 4,\n\t\tpos5 = 5,\n        diagnostics = false,\n        clickX = 0,\n        clickY = 0,\n\t}\n\n    local json = require('dkjson')\n    newState = json.decode(getInput()) or {}\n    local rx, ry = getResolution()\n    local deltaT = getDeltaTime()\n\n    local symbols = {}\n    \n    --local fascia = loadImage(\"assets.prod.novaquark.com/59180/5cef1cfc-444d-4d4e-af78-0a82c2c93ce3.png\")\n\n    if not init then\n        init = true\n        blinkCounter = 0\n        blinkOn = true\n    end\n\n\tlocal top_layer = createLayer()\n\tlocal font = loadFont('Play-Bold', 14)\n\n\tsetNextStrokeWidth(top_layer, 1) \n\tsetNextStrokeColor(top_layer, 0, 255, 255, 0.8)\n\tsetNextShadow(top_layer, 5, 0, 255, 255, .5)\n\taddLine(top_layer, 140, (ry/2) + (imageSize/2), rx-140, (ry/2) + (imageSize/2))\n\n\tsetNextStrokeWidth(top_layer, 1) \n\tsetNextStrokeColor(top_layer, 0, 255, 255, 0.8) \n\tsetNextShadow(top_layer, 5, 0, 255, 255, .5)\n\taddLine(top_layer, 140, (ry/2) - (imageSize/2), rx-140, (ry/2) - (imageSize/2))\n\n\t-- add line select triangles\n\t local font1 = loadFont('Play-Bold', 30)\n     local font2 = loadFont('Play-Bold', 20)\n     addText(top_layer, font2, newState.pos1, .32*rx, .945*ry)\n     addText(top_layer, font2, newState.pos2, .75*rx, .945*ry)\n     setNextTextAlign(top_layer, AlignH_Center, AlignV_Middle)\n\t addText(top_layer, font2, newState.pos3, rx/2, .83*ry)\n     addText(top_layer, font1, newState.pos4, rx-40, .08*ry)\n\t\n     if newState.diagnostics then\n         addText(top_layer, font, \"CLICK:(\" .. newState.clickX .. \",\" .. newState.clickY.. \")\", 100, ry-80)\n     end\n     \n\t--addImage(top_layer, fascia, 0, 0, rx, ry)\n\n\t-- render cost profiler \n\tif newState.diagnostics then \n\t local layer = createLayer() \n\t local font = loadFont('Play-Bold', 14) \n\t setNextFillColor(layer, 1, 1, 1, 1) \n\t addText(layer, font, string.format('render cost : %d / %d',  getRenderCost(), getRenderCostMax()), 8, 16) \n\tend\n\n\trequestAnimationFrame(1)\n]]","filter":{"args":[{"value":"tickDisplay"}],"signature":"onTimer(tag)","slotKey":"-1"},"key":"3"},{"code":"-- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu\n\nlocal pitchSpeedFactor = 0.8 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nlocal yawSpeedFactor =  1 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nlocal rollSpeedFactor = 1.5 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nlocal brakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01\nlocal brakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nlocal autoRoll = false --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)\nlocal autoRollFactor = 2 --export: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01\nlocal turnAssist = true --export: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is\nlocal turnAssistFactor = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nlocal torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\nlocal finalPitchInput = 0\nlocal finalRollInput = 0\nlocal finalYawInput = 0\nlocal finalBrakeInput =  brakeInput\n\n-- validate params\nif ap.enabled\nthen\n    pitchSpeedFactor = math.max(ap.pitchSpeedFactor, 0.01)\n    yawSpeedFactor = math.max(ap.yawSpeedFactor, 0.01)\n    rollSpeedFactor = math.max(ap.rollSpeedFactor, 0.01)\n    torqueFactor = math.max(ap.torqueFactor, 0.01)\n    brakeSpeedFactor = math.max(ap.brakeSpeedFactor, 0.01)\n    brakeFlatFactor = math.max(ap.brakeFlatFactor, 0.01)\n    autoRollFactor = math.max(ap.autoRollFactor, 0.01)\n    turnAssistFactor = math.max(ap.turnAssistFactor, 0.01)\nelse\n    pitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)\n    yawSpeedFactor = math.max(yawSpeedFactor, 0.01)\n    rollSpeedFactor = math.max(rollSpeedFactor, 0.01)\n    torqueFactor = math.max(torqueFactor, 0.01)\n    brakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)\n    brakeFlatFactor = math.max(brakeFlatFactor, 0.01)\n    autoRollFactor = math.max(autoRollFactor, 0.01)\n    turnAssistFactor = math.max(turnAssistFactor, 0.01)\nend\n\n-- final inputs\nif ap.enabled\nthen\n    finalPitchInput = pitchInput + ap.forwardInput\n    finalRollInput = rollInput + ap.yawInput\n    finalYawInput = yawInput - ap.leftRightInput\n    finalBrakeInput =  brakeInput\nelse\n    finalPitchInput = pitchInput + system.getControlDeviceForwardInput()\n    finalRollInput = rollInput + system.getControlDeviceYawInput()\n    finalYawInput = yawInput - system.getControlDeviceLeftRightInput()\n    finalBrakeInput = brakeInput\nend\n\n\n-- Axis\nlocal worldVertical = vec3(core.getWorldVertical()) -- along gravity\nlocal constructUp = vec3(construct.getWorldOrientationUp())\nlocal constructForward = vec3(construct.getWorldOrientationForward())\nlocal constructRight = vec3(construct.getWorldOrientationRight())\nlocal constructVelocity = vec3(construct.getWorldVelocity())\nlocal constructVelocityDir = vec3(construct.getWorldVelocity()):normalize()\nlocal currentRollDeg = getRoll(worldVertical, constructForward, constructRight)\nlocal currentRollDegAbs = math.abs(currentRollDeg)\nlocal currentRollDegSign = utils.sign(currentRollDeg)\n\n-- Rotation\nlocal constructAngularVelocity = vec3(construct.getWorldAngularVelocity())\nlocal targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight\n                                + finalRollInput * rollSpeedFactor * constructForward\n                                + finalYawInput * yawSpeedFactor * constructUp\n\n\n\n-- Auto Level Code \n-- In atmosphere?\nif worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then\n    local autoRollRollThreshold = 1.0\n    -- autoRoll on AND currentRollDeg is big enough AND player is not rolling\n    if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then\n        local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);  -- we go back to 0 within a certain limit\n        if (rollPID == nil) then\n            rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range\n        end\n        rollPID:inject(targetRollDeg - currentRollDeg)\n        local autoRollInput = rollPID:get()\n\n        targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward\n    end\n    local turnAssistRollThreshold = 20.0\n    -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing\n    if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then\n        local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range\n        local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range\n\n        -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)\n        local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180\n        local rollVerticalRatio = 0\n        if rescaleRollDegAbs < 90 then\n            rollVerticalRatio = rescaleRollDegAbs / 90\n        elseif rescaleRollDegAbs < 180 then\n            rollVerticalRatio = (180 - rescaleRollDegAbs) / 90\n        end\n\n        rollVerticalRatio = rollVerticalRatio * rollVerticalRatio\n\n        local turnAssistYawInput = - currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)\n        local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio\n\n        targetAngularVelocity = targetAngularVelocity\n                            + turnAssistPitchInput * constructRight\n                            + turnAssistYawInput * constructUp\n    end\nend\n\n-- Engine commands\nlocal keepCollinearity = 1 -- for easier reading\nlocal dontKeepCollinearity = 0 -- for easier reading\nlocal tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities\n\nif ap.enabled\nthen\n    keepCollinearity = ap.keepCollinearity\n    dontKeepCollinearity = ap.dontKeepCollinearity\n    tolerancePercentToSkipOtherPriorities = ap.tolerancePercentToSkipOtherPriorities\nend\n\n-- Rotation\nlocal angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)\nlocal airAcceleration = vec3(construct.getWorldAirFrictionAngularAcceleration())\nangularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction\nNav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)\n\n-- Brakes\nif not ap.enabled then\n    local brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)\n    Nav:setEngineForceCommand('brake', brakeAcceleration)\nend\n\n-- AutoNavigation regroups all the axis command by 'TargetSpeed'\nlocal autoNavigationEngineTags = ''\nlocal autoNavigationAcceleration = vec3()\nlocal autoNavigationUseBrake = false\n\n-- Longitudinal Translation\nlocal longitudinalEngineTags = 'thrust analog longitudinal'\nlocal longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\nlocal longitudinalAcceleration = 0\n\nif ap.enabled\nthen\n    Nav.axisCommandManager:setTargetSpeedCommand(axisCommandId.longitudinal, ap.longitudinalAcceleration)\n    longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration\nelse\n    longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)\n    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)\nend\n\nif (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop\n    Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking\nthen\n    autoNavigationUseBrake = true\nend\n\n-- Lateral Translation\nlocal lateralStrafeEngineTags = 'thrust analog lateral'\nlocal lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)\nlocal lateralStrafeAcceleration = 0\nif ap.enabled\nthen\n    Nav.axisCommandManager:setTargetSpeedCommand(axisCommandId.lateral, ap.lateralAcceleration)\n    autoNavigationAcceleration = autoNavigationAcceleration + Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags\nelse\n    lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)\n    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)\nend\n\n-- Vertical Translation\nlocal verticalStrafeEngineTags = 'thrust analog vertical'\nlocal verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)\nlocal verticalStrafeAcceleration = 0\n\nif ap.enabled\nthen\n    Nav.axisCommandManager:setTargetSpeedCommand(axisCommandId.vertical, ap.verticalAcceleration)\n    verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)\n    autoNavigationAcceleration = autoNavigationAcceleration + Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags\nelse\n    verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)\n    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)\nend\n\n-- Auto Navigation (Cruise Control)\nif (autoNavigationAcceleration:len() > constants.epsilon) then\n    if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward\n    then\n        autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'\n    end\n    \n    Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)\nend\n\n-- Rockets\nNav:setBoosterCommand('rocket_engine')\n","filter":{"args":[],"signature":"onFlush()","slotKey":"-4"},"key":"4"},{"code":"Nav:update()","filter":{"args":[],"signature":"onUpdate()","slotKey":"-4"},"key":"5"},{"code":"gearExtended = not gearExtended\nif gearExtended then\n    unit.deployLandingGears()\nelse\n    unit.retractLandingGears()\nend\n","filter":{"args":[{"value":"gear"}],"signature":"onActionStart(gear)","slotKey":"-4"},"key":"6"},{"code":"if unit.isAnyHeadlightSwitchedOn() == 1 then\n    unit.switchOffHeadlights()\nelse\n    unit.switchOnHeadlights()\nend\n","filter":{"args":[{"value":"light"}],"signature":"onActionStart(light)","slotKey":"-4"},"key":"7"},{"code":"pitchInput = pitchInput - 1","filter":{"args":[{"value":"forward"}],"signature":"onActionStart(forward)","slotKey":"-4"},"key":"8"},{"code":"pitchInput = pitchInput + 1","filter":{"args":[{"value":"forward"}],"signature":"onActionStop(forward)","slotKey":"-4"},"key":"9"},{"code":"pitchInput = pitchInput + 1","filter":{"args":[{"value":"backward"}],"signature":"onActionStart(backward)","slotKey":"-4"},"key":"10"},{"code":"pitchInput = pitchInput - 1","filter":{"args":[{"value":"backward"}],"signature":"onActionStop(backward)","slotKey":"-4"},"key":"11"},{"code":"rollInput = rollInput - 1","filter":{"args":[{"value":"left"}],"signature":"onActionStart(left)","slotKey":"-4"},"key":"12"},{"code":"rollInput = rollInput + 1","filter":{"args":[{"value":"left"}],"signature":"onActionStop(left)","slotKey":"-4"},"key":"13"},{"code":"rollInput = rollInput + 1","filter":{"args":[{"value":"right"}],"signature":"onActionStart(right)","slotKey":"-4"},"key":"14"},{"code":"rollInput = rollInput - 1","filter":{"args":[{"value":"right"}],"signature":"onActionStop(right)","slotKey":"-4"},"key":"15"},{"code":"Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)","filter":{"args":[{"value":"straferight"}],"signature":"onActionStart(straferight)","slotKey":"-4"},"key":"16"},{"code":"Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)","filter":{"args":[{"value":"straferight"}],"signature":"onActionStop(straferight)","slotKey":"-4"},"key":"17"},{"code":"Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)","filter":{"args":[{"value":"strafeleft"}],"signature":"onActionStart(strafeleft)","slotKey":"-4"},"key":"18"},{"code":"Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)","filter":{"args":[{"value":"strafeleft"}],"signature":"onActionStop(strafeleft)","slotKey":"-4"},"key":"19"},{"code":"Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()\nNav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)\n","filter":{"args":[{"value":"up"}],"signature":"onActionStart(up)","slotKey":"-4"},"key":"20"},{"code":"Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)\nNav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)\n","filter":{"args":[{"value":"up"}],"signature":"onActionStop(up)","slotKey":"-4"},"key":"21"},{"code":"Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()\nNav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)\n","filter":{"args":[{"value":"down"}],"signature":"onActionStart(down)","slotKey":"-4"},"key":"22"},{"code":"Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)\nNav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)\n","filter":{"args":[{"value":"down"}],"signature":"onActionStop(down)","slotKey":"-4"},"key":"23"},{"code":"Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)","filter":{"args":[{"value":"groundaltitudeup"}],"signature":"onActionStart(groundaltitudeup)","slotKey":"-4"},"key":"24"},{"code":"Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)","filter":{"args":[{"value":"groundaltitudeup"}],"signature":"onActionLoop(groundaltitudeup)","slotKey":"-4"},"key":"25"},{"code":"Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)","filter":{"args":[{"value":"groundaltitudedown"}],"signature":"onActionStart(groundaltitudedown)","slotKey":"-4"},"key":"26"},{"code":"Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)","filter":{"args":[{"value":"groundaltitudedown"}],"signature":"onActionLoop(groundaltitudedown)","slotKey":"-4"},"key":"27"},{"code":"yawInput = yawInput - 1","filter":{"args":[{"value":"yawright"}],"signature":"onActionStart(yawright)","slotKey":"-4"},"key":"28"},{"code":"yawInput = yawInput + 1","filter":{"args":[{"value":"yawright"}],"signature":"onActionStop(yawright)","slotKey":"-4"},"key":"29"},{"code":"yawInput = yawInput + 1","filter":{"args":[{"value":"yawleft"}],"signature":"onActionStart(yawleft)","slotKey":"-4"},"key":"30"},{"code":"yawInput = yawInput - 1","filter":{"args":[{"value":"yawleft"}],"signature":"onActionStop(yawleft)","slotKey":"-4"},"key":"31"},{"code":"brakeInput = brakeInput + 1\nlocal longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\nif (longitudinalCommandType == axisCommandType.byTargetSpeed) then\n    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)\n    if (math.abs(targetSpeed) > constants.epsilon) then\n        Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, - utils.sign(targetSpeed))\n    end\nend\n","filter":{"args":[{"value":"brake"}],"signature":"onActionStart(brake)","slotKey":"-4"},"key":"32"},{"code":"brakeInput = brakeInput - 1","filter":{"args":[{"value":"brake"}],"signature":"onActionStop(brake)","slotKey":"-4"},"key":"33"},{"code":"local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\nif (longitudinalCommandType == axisCommandType.byTargetSpeed) then\n    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)\n    if (math.abs(targetSpeed) > constants.epsilon) then\n        Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, - utils.sign(targetSpeed))\n    end\nend\n","filter":{"args":[{"value":"brake"}],"signature":"onActionLoop(brake)","slotKey":"-4"},"key":"34"},{"code":"Nav:toggleBoosters()","filter":{"args":[{"value":"booster"}],"signature":"onActionStart(booster)","slotKey":"-4"},"key":"35"},{"code":"Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)","filter":{"args":[{"value":"stopengines"}],"signature":"onActionStart(stopengines)","slotKey":"-4"},"key":"36"},{"code":"Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 5.0)","filter":{"args":[{"value":"speedup"}],"signature":"onActionStart(speedup)","slotKey":"-4"},"key":"37"},{"code":"Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, 1.0)","filter":{"args":[{"value":"speedup"}],"signature":"onActionLoop(speedup)","slotKey":"-4"},"key":"38"},{"code":"Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -5.0)","filter":{"args":[{"value":"speeddown"}],"signature":"onActionStart(speeddown)","slotKey":"-4"},"key":"39"},{"code":"Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -1.0)","filter":{"args":[{"value":"speeddown"}],"signature":"onActionLoop(speeddown)","slotKey":"-4"},"key":"40"},{"code":"if antigrav ~= nil then antigrav.toggle() end","filter":{"args":[{"value":"antigravity"}],"signature":"onActionStart(antigravity)","slotKey":"-4"},"key":"41"},{"code":"ap.enabled = not ap.enabled","filter":{"args":[{"value":"option1"}],"signature":"onActionStart(action)","slotKey":"-4"},"key":"42"},{"code":"Planet = {}\nfunction Planet:new(system,id,surfaceArea,center,radius)\n    local o = {}\n    setmetatable(o, self)\n    self.__index = self\n    self.system = system\n    self.id = id\n    self.surfaceArea = surfaceArea or 0\n    self.center = center or vec3(0,0,0)\n    self.radius = radius or 0\n    return o\nend\n\n\nAutoPilot = {}\nfunction AutoPilot:new(enabled)\n    local o = {}\n    setmetatable(o, self)\n    self.__index = self\n    self.enabled = enabled\n    self.currentPlanet = nil\n    self.currentPosition = 0\n    self.currentAltitude = 0\n    self.currentTarget = vec3(0,0,0)\n    self.positionHoldEnabled = false\n    self.targetAltitude = 0\n    self.altitudePID = pid.new(0.1,0.00001,0.5)\n    self.thrustUp = unit.getEngineThrust(\"thrustUp\")\n    self.thrustDown = unit.getEngineThrust(\"thrustDown\")\n    self.thrustRight = unit.getEngineThrust(\"thrustRight\")\n    self.thrustLeft = unit.getEngineThrust(\"thrustLeft\")\n    self.thrustForwards = unit.getEngineThrust(\"thrustForwards\")\n    self.thrustBack = unit.getEngineThrust(\"thrustBack\")\n    self.brakeInput = brakeInput\n    self.pitchSpeedFactor = 0\n    self.yawSpeedFactor = 0\n    self.rollSpeedFactor = 0\n    self.torqueFactor = 0\n    self.brakeSpeedFactor = 0\n    self.brakeFlatFactor = 0\n    self.autoRollFactor = 0\n    self.turnAssistFactor = 0\n    self.forwardInput = system.getControlDeviceForwardInput()\n    self.yawInput = system.getControlDeviceYawInput()\n    self.leftRightInput = system.getControlDeviceLeftRightInput()\n    self.keepCollinearity = 1 -- for easier reading\n    self.dontKeepCollinearity = 0 -- for easier reading\n    self.tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities\n    return o\nend\n\nfunction timeToTarget(distance, currentSpeed)\n    return distannce/currentspeed\nend\n\nfunction stoppingDistance(velocity, gravity, friction)\n    return math.pow(velocity,2) / 2 * friction * gravity\nend\n\nfunction round(num, precision)\n    local mult = 10^(precision or 0)\n    return math.floor(num * mult + 0.5) / mult\nend \n\nfunction getAltitude(currentPosition, currentPlanet)\n    local coords = currentPosition - currentPlanet.center\n    local distance = coords:len()\n    return distance - currentPlanet.radius  \nend\n\nfunction getDestination(center, location, height)\n\tlocal dx = location.x - center.x\n\tlocal dy = location.y - center.y\n\tlocal dz = location.z - center.z\n\tlocal k = math.sqrt( (height^2) / ((dx^2)+ (dy^2)+(dz^2)) )\n\tlocal x3 = location.x + dx * k;\n\tlocal y3 = location.y + dy * k;\n\tlocal z3 = location.z + dz * k;\n\treturn vec3({x3,y3,z3})\nend\n\nfunction getSystemPosition(currentPosition)\n    local coords = currentPosition - Alioth.center\n    local distance = coords:len()\n    local altitude = distance - Alioth.radius\n    local latitude = 0\n    local longitude = 0\n    local phi = math.atan(coords.y, coords.x)\n    longitude = phi >= 0 and phi or (2 * math.pi + phi)\n    latitude = math.pi / 2 - math.acos(coords.z / distance)\n    return \"::pos{0,2,\"..math.deg(latitude)..\",\"..math.deg(longitude)..\",\"..altitude..\"}\"\nend\n\n","filter":{"args":[],"signature":"onStart()","slotKey":"-5"},"key":"43"}],"methods":[],"events":[]}