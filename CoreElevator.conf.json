{
    "slots": {
        "0": {
            "name": "core",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "1": {
            "name": "atmofueltank_1",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "2": {
            "name": "screenMain",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "3": {
            "name": "screenTelemetry",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "4": {
            "name": "slot5",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "5": {
            "name": "slot6",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "6": {
            "name": "slot7",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "7": {
            "name": "slot8",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "8": {
            "name": "slot9",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "9": {
            "name": "slot10",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "-1": {
            "name": "unit",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "-3": {
            "name": "player",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "-2": {
            "name": "construct",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "-4": {
            "name": "system",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "-5": {
            "name": "library",
            "type": {
                "events": [],
                "methods": []
            }
        }
    },
    "handlers": [
        {
            "code": "-- category panel display helpers\n_autoconf = {}\n_autoconf.panels = {}\n_autoconf.panels_size = 0\n_autoconf.displayCategoryPanel = f
            unction(elements, size, title, type, widgetPerData)\n    widgetPerData = widgetPerData or false -- default to one widget for all data\n    if size > 0 then\n        local panel = system.createWidgetPanel(title)\n        local widget\n        if not widgetPerData then\n            widget = system.createWidget(panel, type)\n        end\n        for i = 1, size do\n            if widgetPerData then\n                widget = system.createWidget(panel, type)\n            end\n            system.addDataToWidget(elements[i].getWidgetDataId(), widget)\n        end\n        _autoconf.panels_size = _autoconf.panels_size + 1\n        _autoconf.panels[_autoconf.panels_size] = panel\n    end\nend\n_autoconf.hideCategoryPanels = function()\n    for i=1,_autoconf.panels_size do\n        system.destroyWidgetPanel(_autoconf.panels[i])\n    end\nend\n-- Proxy array to access auto-plugged slots programmatically\n\natmofueltank = {}\natmofueltank[1] = atmofueltank_1\natmofueltank_size = 1\n\nspacefueltank = {}\nspacefueltank_size = 0\n\nrocketfueltank = {}\nrocketfueltank_size = 0\n\nweapon = {}\nweapon_size = 0\n\nradar = {}\nradar_size = 0\n-- End of auto-generated code\npitchInput = 0\nrollInput = 0\nyawInput = 0\nbrakeInput = 0\n\nNav = Navigator.new(system, core, unit)\nNav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {1000, 5000, 10000, 20000, 30000})\nNav.axisCommandManager:setTargetGroundAltitude(150)\n\n-- Parenting widget\nparentingPanelId = system.createWidgetPanel(\"Docking\")\nparentingWidgetId = system.createWidget(parentingPanelId,\"parenting\")\nsystem.addDataToWidget(unit.getWidgetDataId(),parentingWidgetId)\n\n-- Combat stress widget\ncoreCombatStressPanelId = system.createWidgetPanel(\"Core combat stress\")\ncoreCombatStressgWidgetId = system.createWidget(coreCombatStressPanelId,\"core_stress\")\nsystem.addDataToWidget(core.getWidgetDataId(),coreCombatStressgWidgetId)\n\n-- element widgets\n-- For now we have to alternate between PVP and non-PVP widgets to have them on the same side.\n_autoconf.displayCategoryPanel(weapon, weapon_size, \"Weapons\", \"weapon\", true)\ncore.showWidget()\n_autoconf.displayCategoryPanel(radar, radar_size, \"Periscope\", \"periscope\")\nplaceRadar = true\nif atmofueltank_size > 0 then\n    _autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, \"Atmo Fuel\", \"fuel_container\")\n    if placeRadar then\n        _autoconf.displayCategoryPanel(radar, radar_size, \"Radar\", \"radar\")\n        placeRadar = false\n    end\nend\nif spacefueltank_size > 0 then\n    _autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, \"Space Fuel\", \"fuel_container\")\n    if placeRadar then\n        _autoconf.displayCategoryPanel(radar, radar_size, \"Radar\", \"radar\")\n        placeRadar = false\n    end\nend\n
            _autoconf.displayCategoryPanel(rocketfueltank, rocketfueltank_size, \"Rocket Fuel\", \"fuel_container\")\nif placeRadar then -- We either have only rockets or no fuel tanks at all, uncommon for usual vessels\n    _autoconf.displayCategoryPanel(radar, radar_size, \"Radar\", \"radar\")\n    placeRadar = false\nend\nif antigrav ~= nil then antigrav.showWidget() end\nif warpdrive ~= nil then warpdrive.showWidget() end\nif gyro ~= nil then gyro.showWidget() end\nif shield ~= nil then shield.showWidget() end\n\n-- freeze the player in he is remote controlling the construct\nif unit.isRemoteControlled() == 1 then\n    player.freeze(1)\nend\n\n-- landing gear\n-- make sure every gears are synchonized with the first\ngearExtended = (unit.isAnyLandingGearDeployed() == 1) -- make sure it's a lua boolean\nif gearExtended then\n    unit.deployLandingGears()\nelse\n    unit.retractLandingGears()\nend\n\n\nAlioth = Planet:new(0, 0, 199718.78, vec3(-8.0000, -8.0000, -126303.0000), 126067.8984375)\n\nap = AutoPilot:new(false)\nap.currentPlanet = Alioth\nap.targetAltitude = 125\nap.currentTarget = getDestination(ap.currentPlanet.center, vec3(construct.getWorldPosition()), ap.targetAltitude)\nap.positionHoldEnabled = true\n\nunit.setTimer(\"tickAltitude\", 0.1)\nunit.setTimer(\"tickDisplay\", 0.5)",
            "filter": {
                "args": [],
                "signature": "onStart()",
                "slotKey": "-1"
            },
            "key": "0"
        },
        {
            "code": "_autoconf.hideCategoryPanels()\nif antigrav ~= nil then antigrav.hideWidget() end\nif warpdrive ~= nil then warpdrive.hideWidget() end\nif gyro ~= nil then gyro.hideWidget() end\ncore.hideWidget()\nunit.switchOffHeadlights()\n",
            "filter": {
                "args": [],
                "signature": "onStop()",
                "slotKey": "-1"
            },
            "key": "1"
        },
        {
            "code": "--tickAltitude(TickRate:0.1)\n\n--initalize\nif not altitudeInit then\n    altitudeInit = true\n\n    verticalThrustSolution = vec3(0,0,0)\nend\n\n-- only do calculations when ap is on\nif ap.enabled then\n    \n    ap.currentPosition = vec3(construct.getWorldPosition())\n    ap.currentAltitude = getAltitude(ap.currentPosition, ap.currentPlanet)\n    ap.currentVelocity = construct.getWorldAbsoluteVelocity()\n    ap.currentAcceleration = construct.getWorldAcceleration()\n    ap.altitudePID:inject(ap.targetAltitude - ap.currentAltitude)\n    ap.thrustUp = unit.getEngineThrust(\"thrustUp\")\n    ap.thrustDown = unit.getEngineThrust(\"thrustDown\")\n    ap.thrustRight = unit.getEngineThrust(\"thrustRight\")\n    ap.thrustLeft = unit.getEngineThrust(\"thrustLeft\")\n    ap.thrustForwards = unit.getEngineThrust(\"thrustForwards\")\n    ap.thrustBack = unit.getEngineThrust(\"thrustBack\")\n    ap.pitchSpeedFactor = 0\n    ap.yawSpeedFactor = 0\n    ap.rollSpeedFactor = 0\n    ap.torqueFactor = 0\n    ap.brakeSpeedFactor = 0\n    ap.brakeFlatFactor = 0\n    ap.autoRollFactor = 0\n    ap.turnAssistFactor = 0\n    ap.forwardInput = system.getControlDeviceForwardInput()\n    ap.yawInput = system.getControlDeviceYawInput()\n    ap.leftRightInput = system.getControlDeviceLeftRightInput()\n    ap.longitudinalAcceleration = 10\n    ap.lateralAcceleration = 10\n    ap.verticalAcceleration = 10\n    ap.brakeInput = brakeInput\n    -- figure out verticalThrustSolution\nend\n",
            "filter": {
                "args": [
                    {
                        "value": "tickAltitude"
                    }
                ],
                "signature": "onTimer(tag)",
                "slotKey": "-1"
            },
            "key": "2"
        },
        {
            "code": "--tickDisplay(TickRate:0.5)\n\n--initalize\nif not displayInit then\n    displayInit = true\n    fontSize = \"2.1\"\n    NavigationCode = \"\"\n    Object = Nav.control\nend\nNavigationCode = \"\"\n\nfor key,value in pairs(Object) do\n    NavigationCode = NavigationCode .. key .. \", \"\nend\n\n--screenMain.setHTML(tohtml_table(NavigationCode, Nav.control, 2.5))\nscreenMain.setCenteredText(tostring(Object) .. \"\\r\\n\" .. NavigationCode)\n",
            "filter": {
                "args": [
                    {
                        "value": "tickDisplay"
                    }
                ],
                "signature": "onTimer(tag)",
                "slotKey": "-1"
            },
            "key": "3"
        },
        {
            "code": "-- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu\n\nlocal pitchSpeedFactor = 0.8 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nlocal yawSpeedFactor =  1 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nlocal rollSpeedFactor = 1.5 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nlocal brakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01\nlocal brakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nlocal autoRoll = false --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)\nlocal autoRollFactor = 2 --export: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01\nlocal turnAssist = true --export: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is\nlocal turnAssistFactor = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nlocal torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\nlocal finalPitchInput = 0\nlocal finalRollInput = 0\nlocal finalYawInput = 0\nlocal finalBrakeInput =  brakeInput\n\n-- validate params\nif ap.enabled\nthen\n    pitchSpeedFactor = math.max(ap.pitchSpeedFactor, 0.01)\n    yawSpeedFactor = math.max(ap.yawSpeedFactor, 0.01)\n    rollSpeedFactor = math.max(ap.rollSpeedFactor, 0.01)\n    torqueFactor = math.max(ap.torqueFactor, 0.01)\n    brakeSpeedFactor = math.max(ap.brakeSpeedFactor, 0.01)\n    brakeFlatFactor = math.max(ap.brakeFlatFactor, 0.01)\n    autoRollFactor = math.max(ap.autoRollFactor, 0.01)\n    turnAssistFactor = math.max(ap.turnAssistFactor, 0.01)\nelse\n    pitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)\n    yawSpeedFactor = math.max(yawSpeedFactor, 0.01)\n    rollSpeedFactor = math.max(rollSpeedFactor, 0.01)\n    torqueFactor = math.max(torqueFactor, 0.01)\n    brakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)\n    brakeFlatFactor = math.max(brakeFlatFactor, 0.01)\n    autoRollFactor = math.max(autoRollFactor, 0.01)\n    turnAssistFactor = math.max(turnAssistFactor, 0.01)\nend\n\n-- final inputs\nif ap.enabled\nthen\n    local finalPitchInput = pitchInput + ap.forwardInput\n    local finalRollInput = rollInput + ap.yawInput\n    local finalYawInput = yawInput - ap.leftRightInput\n    local finalBrakeInput =  ap.brakeInput\nelse\n    local finalPitchInput = pitchInput + system.getControlDeviceForwardInput()\n    local finalRollInput = rollInput + system.getControlDeviceYawInput()\n    local finalYawInput = yawInput - system.getControlDeviceLeftRightInput()\n    local finalBrakeInput = brakeInput\nend\n\n\n-- Axis\nlocal worldVertical = vec3(core.getWorldVertical()) -- along gravity\nlocal constructUp = vec3(construct.getWorldOrientationUp())\nlocal constructForward = vec3(construct.getWorldOrientationForward())\nlocal constructRight = vec3(construct.getWorldOrientationRight())\nlocal constructVelocity = vec3(construct.getWorldVelocity())\nlocal constructVelocityDir = vec3(construct.getWorldVelocity()):normalize()\nlocal currentRollDeg = getRoll(worldVertical, constructForward, constructRight)\nlocal currentRollDegAbs = math.abs(currentRollDeg)\nlocal currentRollDegSign = utils.sign(currentRollDeg)\n\n-- Rotation\nlocal constructAngularVelocity = vec3(construct.getWorldAngularVelocity())\nlocal targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight\n                                + finalRollInput * rollSpeedFactor * constructForward\n                                + finalYawInput * yawSpeedFactor * constructUp\n\n-- In atmosphere?\nif worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then\n    local autoRollRollThreshold = 1.0\n    -- autoRoll on AND currentRollDeg is big enough AND player is not rolling\n    if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then\n        local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);  -- we go back to 0 within a certain limit\n        if (rollPID == nil) then\n            rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range\n        end\n        rollPID:inject(targetRollDeg - currentRollDeg)\n        local autoRollInput = rollPID:get()\n\n        targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward\n    end\n    local turnAssistRollThreshold = 20.0\n    -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing\n    if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then\n        local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range\n        local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range\n\n        -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)\n        local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180\n        local rollVerticalRatio = 0\n        if rescaleRollDegAbs < 90 then\n            rollVerticalRatio = rescaleRollDegAbs / 90\n        elseif rescaleRollDegAbs < 180 then\n            rollVerticalRatio = (180 - rescaleRollDegAbs) / 90\n        end\n\n        rollVerticalRatio = rollVerticalRatio * rollVerticalRatio\n\n        local turnAssistYawInput = - currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)\n        local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio\n\n        targetAngularVelocity = targetAngularVelocity\n                            + turnAssistPitchInput * constructRight\n                            + turnAssistYawInput * constructUp\n    end\nend\n\n-- Engine commands\nlocal keepCollinearity = 1 -- for easier reading\nlocal dontKeepCollinearity = 0 -- for easier reading\nlocal tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities\n\nif ap.enabled\nthen\n    keepCollinearity = ap.keepCollinearity\n    dontKeepCollinearity = ap.dontKeepCollinearity\n    tolerancePercentToSkipOtherPriorities = ap.tolerancePercentToSkipOtherPriorities\nend\n\n-- Rotation\nlocal angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)\nlocal airAcceleration = vec3(construct.getWorldAirFrictionAngularAcceleration())\nangularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction\nNav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)\n\n-- Brakes\nlocal brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)\nNav:setEngineForceCommand('brake', brakeAcceleration)\n\n-- AutoNavigation regroups all the axis command by 'TargetSpeed'\nlocal autoNavigationEngineTags = ''\nlocal autoNavigationAcceleration = vec3()\nlocal autoNavigationUseBrake = false\n\n-- Longitudinal Translation\nlocal longitudinalEngineTags = 'thrust analog longitudinal'\nlocal longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\nlocal longitudinalAcceleration = 0\nif ap.enabled\nthen\n    longitudinalAcceleration = ap.longitudinalAcceleration\nelse\n    longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)\nend\n\nif (longitudinalCommandType == axisCommandType.byThrottle) then\n    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)\nelseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then\n    longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration\nend\n\n
            if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop\n    Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking\nthen\n    autoNavigationUseBrake = true\n    ap.brakeInput = true\nend\n\n-- Lateral Translation\nlocal lateralStrafeEngineTags = 'thrust analog lateral'\nlocal lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)\nlocal lateralStrafeAcceleration = 0\nif ap.enabled\nthen\n    lateralStrafeAcceleration =  ap.lateralAcceleration\nelse\n    lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)\nend\nif (lateralCommandType == axisCommandType.byThrottle) then\n    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)\nelseif  (lateralCommandType == axisCommandType.byTargetSpeed) then\n    autoNavigationAcceleration = autoNavigationAcceleration + Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags\nend\n\n-- Vertical Translation\nlocal verticalStrafeEngineTags = 'thrust analog vertical'\nlocal verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)\nlocal verticalStrafeAcceleration = 0\nif ap.enabled\nthen\n    verticalStrafeAcceleration = ap.verticalAcceleration\nelse\n    verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)\nend\nif (verticalCommandType == axisCommandType.byThrottle) then\n    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)\nelseif  (verticalCommandType == axisCommandType.byTargetSpeed) then\n    autoNavigationAcceleration = autoNavigationAcceleration + Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags \nend\n\n-- Auto Navigation (Cruise Control)\nif (autoNavigationAcceleration:len() > constants.epsilon) then\n    if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward\n    then\n        autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'\n    end\n    if ap.enabled\n    then\n        Nav:setEngineForceCommand(autoNavigationEngineTags, ap.NavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)\n    else\n        Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)\n    end\nend\n\n-- Rockets\nNav:setBoosterCommand('rocket_engine')\n\n\n",
            "filter": {
                "args": [],
                "signature": "onFlush()",
                "slotKey": "-4"
            },
            "key": "4"
        },
        {
            "code": "Nav:update()",
            "filter": {
                "args": [],
                "signature": "onUpdate()",
                "slotKey": "-4"
            },
            "key": "5"
        },
        {
            "code": "gearExtended = not gearExtended\nif gearExtended then\n    unit.deployLandingGears()\nelse\n    unit.retractLandingGears()\nend\n",
            "filter": {
                "args": [
                    {
                        "value": "gear"
                    }
                ],
                "signature": "onActionStart(gear)",
                "slotKey": "-4"
            },
            "key": "6"
        },
        {
            "code": "if unit.isAnyHeadlightSwitchedOn() == 1 then\n    unit.switchOffHeadlights()\nelse\n    unit.switchOnHeadlights()\nend\n",
            "filter": {
                "args": [
                    {
                        "value": "light"
                    }
                ],
                "signature": "onActionStart(light)",
                "slotKey": "-4"
            },
            "key": "7"
        },
        {
            "code": "pitchInput = pitchInput - 1",
            "filter": {
                "args": [
                    {
                        "value": "forward"
                    }
                ],
                "signature": "onActionStart(forward)",
                "slotKey": "-4"
            },
            "key": "8"
        },
        {
            "code": "pitchInput = pitchInput + 1",
            "filter": {
                "args": [
                    {
                        "value": "forward"
                    }
                ],
                "signature": "onActionStop(forward)",
                "slotKey": "-4"
            },
            "key": "9"
        },
        {
            "code": "pitchInput = pitchInput + 1",
            "filter": {
                "args": [
                    {
                        "value": "backward"
                    }
                ],
                "signature": "onActionStart(backward)",
                "slotKey": "-4"
            },
            "key": "10"
        },
        {
            "code": "pitchInput = pitchInput - 1",
            "filter": {
                "args": [
                    {
                        "value": "backward"
                    }
                ],
                "signature": "onActionStop(backward)",
                "slotKey": "-4"
            },
            "key": "11"
        },
        {
            "code": "rollInput = rollInput - 1",
            "filter": {
                "args": [
                    {
                        "value": "left"
                    }
                ],
                "signature": "onActionStart(left)",
                "slotKey": "-4"
            },
            "key": "12"
        },
        {
            "code": "rollInput = rollInput + 1",
            "filter": {
                "args": [
                    {
                        "value": "left"
                    }
                ],
                "signature": "onActionStop(left)",
                "slotKey": "-4"
            },
            "key": "13"
        },
        {
            "code": "rollInput = rollInput + 1",
            "filter": {
                "args": [
                    {
                        "value": "right"
                    }
                ],
                "signature": "onActionStart(right)",
                "slotKey": "-4"
            },
            "key": "14"
        },
        {
            "code": "rollInput = rollInput - 1",
            "filter": {
                "args": [
                    {
                        "value": "right"
                    }
                ],
                "signature": "onActionStop(right)",
                "slotKey": "-4"
            },
            "key": "15"
        },
        {
            "code": "Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)",
            "filter": {
                "args": [
                    {
                        "value": "straferight"
                    }
                ],
                "signature": "onActionStart(straferight)",
                "slotKey": "-4"
            },
            "key": "16"
        },
        {
            "code": "Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)",
            "filter": {
                "args": [
                    {
                        "value": "straferight"
                    }
                ],
                "signature": "onActionStop(straferight)",
                "slotKey": "-4"
            },
            "key": "17"
        },
        {
            "code": "Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)",
            "filter": {
                "args": [
                    {
                        "value": "strafeleft"
                    }
                ],
                "signature": "onActionStart(strafeleft)",
                "slotKey": "-4"
            },
            "key": "18"
        },
        {
            "code": "Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)",
            "filter": {
                "args": [
                    {
                        "value": "strafeleft"
                    }
                ],
                "signature": "onActionStop(strafeleft)",
                "slotKey": "-4"
            },
            "key": "19"
        },
        {
            "code": "Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()\nNav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)\n",
            "filter": {
                "args": [
                    {
                        "value": "up"
                    }
                ],
                "signature": "onActionStart(up)",
                "slotKey": "-4"
            },
            "key": "20"
        },
        {
            "code": "Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)\nNav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)\n",
            "filter": {
                "args": [
                    {
                        "value": "up"
                    }
                ],
                "signature": "onActionStop(up)",
                "slotKey": "-4"
            },
            "key": "21"
        },
        {
            "code": "Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()\nNav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)\n",
            "filter": {
                "args": [
                    {
                        "value": "down"
                    }
                ],
                "signature": "onActionStart(down)",
                "slotKey": "-4"
            },
            "key": "22"
        },
        {
            "code": "Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)\nNav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)\n",
            "filter": {
                "args": [
                    {
                        "value": "down"
                    }
                ],
                "signature": "onActionStop(down)",
                "slotKey": "-4"
            },
            "key": "23"
        },
        {
            "code": "Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)",
            "filter": {
                "args": [
                    {
                        "value": "groundaltitudeup"
                    }
                ],
                "signature": "onActionStart(groundaltitudeup)",
                "slotKey": "-4"
            },
            "key": "24"
        },
        {
            "code": "Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)",
            "filter": {
                "args": [
                    {
                        "value": "groundaltitudeup"
                    }
                ],
                "signature": "onActionLoop(groundaltitudeup)",
                "slotKey": "-4"
            },
            "key": "25"
        },
        {
            "code": "Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)",
            "filter": {
                "args": [
                    {
                        "value": "groundaltitudedown"
                    }
                ],
                "signature": "onActionStart(groundaltitudedown)",
                "slotKey": "-4"
            },
            "key": "26"
        },
        {
            "code": "Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)",
            "filter": {
                "args": [
                    {
                        "value": "groundaltitudedown"
                    }
                ],
                "signature": "onActionLoop(groundaltitudedown)",
                "slotKey": "-4"
            },
            "key": "27"
        },
        {
            "code": "yawInput = yawInput - 1",
            "filter": {
                "args": [
                    {
                        "value": "yawright"
                    }
                ],
                "signature": "onActionStart(yawright)",
                "slotKey": "-4"
            },
            "key": "28"
        },
        {
            "code": "yawInput = yawInput + 1",
            "filter": {
                "args": [
                    {
                        "value": "yawright"
                    }
                ],
                "signature": "onActionStop(yawright)",
                "slotKey": "-4"
            },
            "key": "29"
        },
        {
            "code": "yawInput = yawInput + 1",
            "filter": {
                "args": [
                    {
                        "value": "yawleft"
                    }
                ],
                "signature": "onActionStart(yawleft)",
                "slotKey": "-4"
            },
            "key": "30"
        },
        {
            "code": "yawInput = yawInput - 1",
            "filter": {
                "args": [
                    {
                        "value": "yawleft"
                    }
                ],
                "signature": "onActionStop(yawleft)",
                "slotKey": "-4"
            },
            "key": "31"
        },
        {
            "code": "brakeInput = brakeInput + 1\nlocal longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\nif (longitudinalCommandType == axisCommandType.byTargetSpeed) then\n    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)\n    if (math.abs(targetSpeed) > constants.epsilon) then\n        Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, - utils.sign(targetSpeed))\n    end\nend\n",
            "filter": {
                "args": [
                    {
                        "value": "brake"
                    }
                ],
                "signature": "onActionStart(brake)",
                "slotKey": "-4"
            },
            "key": "32"
        },
        {
            "code": "brakeInput = brakeInput - 1",
            "filter": {
                "args": [
                    {
                        "value": "brake"
                    }
                ],
                "signature": "onActionStop(brake)",
                "slotKey": "-4"
            },
            "key": "33"
        },
        {
            "code": "local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\nif (longitudinalCommandType == axisCommandType.byTargetSpeed) then\n    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)\n    if (math.abs(targetSpeed) > constants.epsilon) then\n        Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, - utils.sign(targetSpeed))\n    end\nend\n",
            "filter": {
                "args": [
                    {
                        "value": "brake"
                    }
                ],
                "signature": "onActionLoop(brake)",
                "slotKey": "-4"
            },
            "key": "34"
        },
        {
            "code": "Nav:toggleBoosters()",
            "filter": {
                "args": [
                    {
                        "value": "booster"
                    }
                ],
                "signature": "onActionStart(booster)",
                "slotKey": "-4"
            },
            "key": "35"
        },
        {
            "code": "Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)",
            "filter": {
                "args": [
                    {
                        "value": "stopengines"
                    }
                ],
                "signature": "onActionStart(stopengines)",
                "slotKey": "-4"
            },
            "key": "36"
        },
        {
            "code": "Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 5.0)",
            "filter": {
                "args": [
                    {
                        "value": "speedup"
                    }
                ],
                "signature": "onActionStart(speedup)",
                "slotKey": "-4"
            },
            "key": "37"
        },
        {
            "code": "Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, 1.0)",
            "filter": {
                "args": [
                    {
                        "value": "speedup"
                    }
                ],
                "signature": "onActionLoop(speedup)",
                "slotKey": "-4"
            },
            "key": "38"
        },
        {
            "code": "Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -5.0)",
            "filter": {
                "args": [
                    {
                        "value": "speeddown"
                    }
                ],
                "signature": "onActionStart(speeddown)",
                "slotKey": "-4"
            },
            "key": "39"
        },
        {
            "code": "Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -1.0)",
            "filter": {
                "args": [
                    {
                        "value": "speeddown"
                    }
                ],
                "signature": "onActionLoop(speeddown)",
                "slotKey": "-4"
            },
            "key": "40"
        },
        {
            "code": "if antigrav ~= nil then antigrav.toggle() end",
            "filter": {
                "args": [
                    {
                        "value": "antigravity"
                    }
                ],
                "signature": "onActionStart(antigravity)",
                "slotKey": "-4"
            },
            "key": "41"
        },
        {
            "code": "ap.enabled = not ap.enabled",
            "filter": {
                "args": [
                    {
                        "value": "option1"
                    }
                ],
                "signature": "onActionStart(action)",
                "slotKey": "-4"
            },
            "key": "42"
        },
        {
            "code": "Planet = {}\nfunction Planet:new(system,id,surfaceArea,center,radius)\n    local o = {}\n    setmetatable(o, self)\n    self.__index = self\n    self.system = system\n    self.id = id\n    self.surfaceArea = surfaceArea or 0\n    self.center = center or vec3(0,0,0)\n    self.radius = radius or 0\n    return o\nend\n\nAutoPilot = {}\nfunction AutoPilot:new(enabled)\n    local o = {}\n    setmetatable(o, self)\n    self.__index = self\n    self.enabled = enabled\n    self.currentPlanet = nil\n    self.currentPosition = 0\n    self.currentAltitude = 0\n    self.currentTarget = vec3(0,0,0)\n    self.positionHoldEnabled = false\n    self.targetAltitude = 0\n    self.altitudePID = pid.new(0.1,0.00001,0.5)\n    self.thrustUp = unit.getEngineThrust(\"thrustUp\")\n    self.thrustDown = unit.getEngineThrust(\"thrustDown\")\n    self.thrustRight = unit.getEngineThrust(\"thrustRight\")\n    self.thrustLeft = unit.getEngineThrust(\"thrustLeft\")\n    self.thrustForwards = unit.getEngineThrust(\"thrustForwards\")\n    self.thrustBack = unit.getEngineThrust(\"thrustBack\")\n    self.brakeInput = brakeInput\n    self.pitchSpeedFactor = 0\n    self.yawSpeedFactor = 0\n    self.rollSpeedFactor = 0\n    self.torqueFactor = 0\n    self.brakeSpeedFactor = 0\n    self.brakeFlatFactor = 0\n    self.autoRollFactor = 0\n    self.turnAssistFactor = 0\n    self.forwardInput = system.getControlDeviceForwardInput()\n    self.yawInput = system.getControlDeviceYawInput()\n    self.leftRightInput = system.getControlDeviceLeftRightInput()\n    self.keepCollinearity = 1 -- for easier reading\n    self.dontKeepCollinearity = 0 -- for easier reading\n    self.tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities\n    return o\nend\n\nfunction timeToTarget(distance, currentSpeed)\n    return distannce/currentspeed\nend\n\nfunction stoppingDistance(velocity, gravity, friction)\n    return math.pow(velocity,2) / 2 * friction * gravity\nend\n\nfunction round(num, precision)\n    local mult = 10^(precision or 0)\n    return math.floor(num * mult + 0.5) / mult\nend \n\nfunction getAltitude(currentPosition, currentPlanet)\n    local coords = currentPosition - currentPlanet.center\n    local distance = coords:len()\n    return distance - currentPlanet.radius  \nend\n\nfunction getDestination(center, location, height)\n\tlocal dx = location.x - center.x\n\tlocal dy = location.y - center.y\n\tlocal dz = location.z - center.z\n\tlocal k = math.sqrt( (height^2) / ((dx^2)+ (dy^2)+(dz^2)) )\n\tlocal x3 = location.x + dx * k;\n\tlocal y3 = location.y + dy * k;\n\tlocal z3 = location.z + dz * k;\n\treturn vec3({x3,y3,z3})\nend\n\nfunction getSystemPosition(currentPosition)\n    local coords = currentPosition - Alioth.center\n    local distance = coords:len()\n    local altitude = distance - Alioth.radius\n    local latitude = 0\n    local longitude = 0\n    local phi = math.atan(coords.y, coords.x)\n    longitude = phi >= 0 and phi or (2 * math.pi + phi)\n    latitude = math.pi / 2 - math.acos(coords.z / distance)\n    return \"::pos{0,2,\"..math.deg(latitude)..\",\"..math.deg(longitude)..\",\"..altitude..\"}\"\nend\n\n--Prints tables that only contain numbers\nfunction printNumericTable(o, precision)\n   if type(o) == 'table' then\n      local s = ''\n      for k,v in pairs(o) do\n          s = s .. printNumericTable(round(v, 2), precision) .. ', '\n      end\n      return s\n   else\n      return tostring(o)\n   end\nend\n\n--Prints JSON style objects from a table\nfunction printTable(o)\n   if type(o) == 'table' then\n      local s = '{ '\n      for k,v in pairs(o) do\n         if type(k) ~= 'number' then k = '\"'..k..'\"' end\n         s = s .. '['..k..'] = ' .. printTable(v) .. ', '\n      end\n      return s .. '} '\n   else\n      return tostring(o)\n   end\nend\n\n-- Converts Lua table to HTML output in table.html file\nfunction tohtml(x)\n  ret = tohtml_table(x,1)\n  writefile(\"table.html\", ret)\n  os.execute(\"table.html\")\n  return(ret)\nend\n\n-- Saves a string to file\nfunction writefile(filename, value)\n  if (value) then\n    local file = io.open(filename,\"w+\")\n    file:write(value)\n    file:close()\n  end\nend\n\n-- Flattens a table to html output\nfunction tohtml_table(x, table_level, title, fontSize)\n  local k, s,  tcolor\n  local html_colors = {\n    \"#339900\",\"#33CC00\",\"#669900\",\"#666600\",\"#FF3300\",\n    \"#FFCC00\",\"#FFFF00\",\"#CCFFCC\",\"#CCCCFF\",\"#CC66FF\",\n    \"#339900\",\"#33CC00\",\"#669900\",\"#666600\",\"#FF3300\",\n    \"#FFCC00\",\"#FFFF00\",\"#CCFFCC\",\"#CCCCFF\",\"#CC66FF\"\n  }\n  local lineout = {}\n  local tablefound = false\n    if type(x) == \"table\" then\n    s = [[\"<div class=\"bootstrap\">\n                <table style=\"\n                    margin-top: auto;\n                    margin-left: auto;\n                    margin-right: auto;\n                    width: 100%;\n                    font-size: ]]..fontSize..[[em;\">\n                        <tr style=\"\n                        \twidth: 50%;\n                        \tbackground-color: White;\n                        \tcolor: black;\">\n                        \t<th class=\"span\" colspan=\"2\">]]..title//[[</th>\n                        </tr>\"]]\n    k = 1\n    local i, v = next(x)\n    while i do\n      if (type(v) == \"table\") then\n        if (table_level<10) then\n          lineout[k] =  \"<b>\" .. flat(i) .. \"</b>\".. tohtml_table(v, table_level + 1)   \n        else\n          lineout[k] = \"<b>MAXIMUM LEVEL BREACHED</b>\"\n        end\n        tablefound = true\n      else\n        lineout[k] = flat(i) .. \"=\" .. tohtml_table(v)\n      end\n      k = k + 1\n      i, v = next(x, i)\n    end\n\n    for k,line in ipairs(lineout) do\n      if (tablefound) then\n        s = s .. \"<tr><td>\" .. line .. \"</td></tr>\\n\"\n      else\n        s = s .. \"<td>\" .. line .. \"</td>\\n\"\n      end\n    end\n    if not (tablefound) then\n      s = \"<table border='1' bgcolor='#FFFFCC' cellpadding='5' cellspacing='0'>\" ..\n        \"<tr>\" .. s .. \"</tr></table>\\n\"\n    else\n      tcolor = html_colors[table_level]\n      s = \"<table border='3' bgcolor='\"..tcolor..\"' cellpadding='10' cellspacing='0'>\" ..\n          s ..  \"</table>\\n\"\n    end\n      s = s .. \"</div>\"\n    return s \n  end\n  if type(x) == \"function\" then\n    return \"FUNC\"\n  end\n  if type(x) == \"file\" then\n    return \"FILE\"\n  end\n\n  return tostring(x) \nend\n\n-- Flattens a table to string\nfunction flat(x)  \n  return toflat(x,1)\nend\n\n-- Flattens a table to string\nfunction toflat(x, tlevel)\n  local s\n  tlevel = tlevel + 1\n\n  if type(x) == \"table\" then\n    s = \"{\"\n    local i, v = next(x)\n    while i do\n      if (tlevel < 15) then\n        s = s .. i .. \"=\" .. toflat(v, tlevel) \n      else\n        s = s .. i .. \"={#}\" \n      end\n\n      i, v = next(x, i)\n      if i then\n        s = s .. \", \" \n      end\n    end\n    return s .. \"}\\n\"\n  end\n  if type(x) == \"function\" then\n    return \"FUNC\"\n  end\n  if type(x) == \"file\" then\n    return \"FILE\"\n  end\n\n  return tostring(x) \nend",
            "filter": {
                "args": [],
                "signature": "onStart()",
                "slotKey": "-5"
            },
            "key": "43"
        }
    ],
    "methods": [],
    "events": []
}